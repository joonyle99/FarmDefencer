using System;
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// 
/// </summary>
public class TargetDetector : MonoBehaviour
{
    [SerializeField] private LayerMask _targetLayerMask;

    [Space]

    private const int BUCKET_CAPACITY = 100;

    [SerializeField] private List<TargetableBehavior> _targetsInRange = new List<TargetableBehavior>(BUCKET_CAPACITY);
    public List<TargetableBehavior> TargetsInRange => _targetsInRange;

    public int range = 3;


    private TargetableBehavior _currentTarget;

    public event Action<TargetableBehavior> OnEnterTarget;
    public event Action<TargetableBehavior> OntExitTarge;
    // public event Action<TargetableBehavior> OnAccquireTarget;       // when you get current target

    // LEARNING POINT
    //
    // Collider2D 컴포넌트
    // -> Unity Physics Engine의 물리 연산과 함께 지속적으로 충돌을 체크한다
    //
    // Physics2D.OverlapCircleAll
    // -> 물리 연산이 아닌, 충돌 체크만을 수행한다

    public TargetableBehavior GetFrontTarget()
    {
        if (_targetsInRange.Count == 0)
        {
            return null;
        }

        return _targetsInRange[0];
    }

    private void Start()
    {
        DetectTargets();
    }
    private void Update()
    {

    }

    private void DetectTargets()
    {
        // 이 TargetDetector가 속한 기준 타일을 선택한다
        var cellPoint = GridMap.Instance.WorldToCell(this.transform.position);

        // 기준 타일에서 range 범위에 해당하는 타일을 찾는다
        for(int h = -range; h <= range; h++)
        {
            for(int w = -range; w <= range; w++)
            {
                // var targetCellPoint = cellPoint + new Vector3Int(w, h, 0);
                var targetcCell = GridMap.Instance.GetCell(w, h);
                targetcCell.transform.localScale *= 2f;

                // var targetWorldPoint = GridMap.Instance.GetCellCenterWorld(targetCellPoint);

                // 해당 타일에 있는 모든 타겟을 찾는다
                // var targets = Physics2D.OverlapCircleAll(targetWorldPoint, GridMap.Instance.UnitCellSize, _targetLayerMask);

                /*
                foreach (var target in targets)
                {
                    if (target.TryGetComponent<TargetableBehavior>(out var targetable))
                    {
                        if (_targetsInRange.Contains(targetable) == false)
                        {
                            _targetsInRange.Add(targetable);
                            OnEnterTarget?.Invoke(targetable);
                        }
                    }
                }
                */
            }
        }

        // 각각의 타일에서 raycast 방식 (overlap이나) 으로 한 칸씩 targetLayer를 체크한다

        // 만약 검출된다면 list에 추가한다
    }

    private void OnTriggerEnter2D(Collider2D collision)
    {
        // check layer
        if (((1 << collision.gameObject.layer) & _targetLayerMask.value) > 0)
        {
            // check targetable
            if (collision.TryGetComponent<TargetableBehavior>(out var targetable))
            {
                if (_targetsInRange.Contains(targetable) == false)
                {
                    _targetsInRange.Add(targetable);
                    OnEnterTarget?.Invoke(targetable);
                }
            }
        }
    }
    private void OnTriggerExit2D(Collider2D collision)
    {
        if (collision.TryGetComponent<TargetableBehavior>(out var targetable))
        {
            if (TargetsInRange.Contains(targetable) == true)
            {
                _targetsInRange.Remove(targetable);
                OntExitTarge?.Invoke(targetable);
            }
        }
    }
}
